<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FLLRobot Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #464646;
        }
        canvas {
            border: 2px solid #1d1d1d;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);            
            background-color: #1d1d1d;
            cursor: grab;
        }
        .code-output {
            background-color: #1f2937;
            color: #ffffff;
            border-radius: 0.5rem;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Courier New', Courier, monospace;
        }
        .instruction-item {
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid #4b5563;
            cursor: grab;
            background-color: #374151;
            color: #d1d5db;
            border-radius: 0.375rem;
            margin-bottom: 0.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .instruction-item.dragging {
            opacity: 0.5;
        }
        .instruction-item:hover {
            background-color: #4b5563;
        }
        .instruction-controls button {
            background: none;
            border: none;
            color: #d1d5db;
            font-size: 0.875rem;
            cursor: pointer;
            padding: 0 0.25rem;
            transition: color 0.2s;
        }
        .instruction-controls button:hover {
            color: #9ca3af;
        }
        .edit-form input {
            background-color: #1f2937;
            color: #d1d5db;
            border: 1px solid #4b5563;
            border-radius: 0.25rem;
            padding: 0.25rem;
            width: 80px;
        }
        .edit-form button {
            background: #22c55e;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full bg-grey-800 p-8 rounded-lg shadow-lg">
        <div class="flex flex-col lg:flex-row gap-8">
            <!-- Controls and Output -->
            <div class="flex-none w-full lg:w-[20%] flex flex-col gap-6">
                <!-- Mission and Start Config -->
                <div class="p-6 bg-gray-800 rounded-lg shadow-sm">
                    <h2 class="text-xl font-semibold mb-4 text-gray-200">Mission and Start Configuration</h2>
                    <div class="mb-4">
                        <label for="missionName" class="block text-sm font-medium text-gray-200">Mission Name</label>
                        <input type="text" id="missionName" value="Robot Mission" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-700 text-gray-200">
                    </div>
                    <div class="grid grid-cols-3 gap-4 mb-4">
                        <div>
                            <label for="startX" class="block text-sm font-medium text-gray-200">Start X (cm)</label>
                            <input type="number" id="startX" value="-93.0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-700 text-gray-200">
                        </div>
                        <div>
                            <label for="startY" class="block text-sm font-medium text-gray-200">Start Y (cm)</label>
                            <input type="number" id="startY" value="-48.0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-700 text-gray-200">
                        </div>
                        <div>
                            <label for="startAngle" class="block text-sm font-medium text-gray-200">Start Angle (deg)</label>
                            <input type="number" id="startAngle" value="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-700 text-gray-200">
                        </div>
                    </div>
                </div>

                <!-- Robot Dimensions Input -->
                <div class="p-6 bg-gray-800 rounded-lg shadow-sm">
                    <h2 class="text-xl font-semibold mb-4 text-gray-200">Robot Dimensions (cm)</h2>
                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div>
                            <label for="robotWidth" class="block text-sm font-medium text-gray-200">Width</label>
                            <input type="number" id="robotWidth" value="12.5" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-700 text-gray-200">
                        </div>
                        <div>
                            <label for="robotHeight" class="block text-sm font-medium text-gray-200">Height</label>
                            <input type="number" id="robotHeight" value="18" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-700 text-gray-200">
                        </div>
                    </div>
                    <div>
                        <label for="pivotY" class="block text-sm font-medium text-gray-200">Pivot Y Offset (cm)</label>
                        <input type="number" id="pivotY" value="0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-700 text-gray-200">
                    </div>
                </div>

                <!-- Command Input -->
                <div class="p-6 bg-gray-800 rounded-lg shadow-sm">
                    <h2 class="text-xl font-semibold mb-4 text-gray-200">Add Command</h2>
                    
                    <div class="grid grid-cols-2 gap-4 my-4">
                        <div>
                            <label for="moveDistance" class="block text-sm font-medium text-gray-200">Move Distance (cm)</label>
                            <input type="number" id="moveDistance" value="50.0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-700 text-gray-200">
                            <label for="moveSpeed" class="block text-sm font-medium text-gray-200 mt-2">Move Speed (0-1000)</label>
                            <input type="number" id="moveSpeed" value="1000" min="0" max="1000" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-700 text-gray-200">
                        </div>
                        <button id="addMoveBtn" class="mt-6 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-300">
                            Add Move
                        </button>
                    </div>

                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="rotateAngle" class="block text-sm font-medium text-gray-200">Rotate Angle (deg)</label>
                            <input type="number" id="rotateAngle" value="90.0" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-700 text-gray-200">
                            <label for="rotateSpeed" class="block text-sm font-medium text-gray-200 mt-2">Rotate Speed (0-1000)</label>
                            <input type="number" id="rotateSpeed" value="500" min="0" max="1000" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-700 text-gray-200">
                        </div>
                        <button id="addRotateBtn" class="mt-6 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-300">
                            Add Rotate
                        </button>
                    </div>
                    
                    <div class="grid grid-cols-2 gap-4 my-4">
                        <button id="addMotor1Btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-300">
                            Add Motor 1 Rotation
                        </button>
                        <button id="addMotor2Btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-300">
                            Add Motor 2 Rotation
                        </button>
                    </div>

                    <button id="resetBtn" class="mt-4 w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-300">
                        Reset
                    </button>
                </div>
                
                <!-- Instruction List -->
                <div class="p-6 bg-gray-800 rounded-lg shadow-sm">
                    <h2 class="text-xl font-semibold mb-4 text-gray-200">Instruction List</h2>
                    <ul id="instructionList" class="text-gray-200 list-inside">
                        <!-- Instructions will be added here dynamically -->
                    </ul>
                </div>

                <!-- Simulation Controls and Path Color -->
                <div class="p-6 bg-gray-800 rounded-lg shadow-sm flex items-center justify-between">
                    <div>
                        <label for="pathColor" class="block text-sm font-medium text-gray-200">Robot Path Color</label>
                        <input type="color" id="pathColor" value="#22c55e" class="mt-1 h-10 w-10 rounded-full border-gray-300 shadow-sm">
                    </div>
                    <div class="ml-4">
                        <label for="robotColor" class="block text-sm font-medium text-gray-200">Robot Color</label>
                        <input type="color" id="robotColor" value="#3b82f6" class="mt-1 h-10 w-10 rounded-full border-gray-300 shadow-sm">
                    </div>
                </div>
            </div>
            <!-- Simulation Canvas and Output -->
            <div class="flex-grow flex-1 w-full lg:w-[80%] flex flex-col justify-start items-start gap-4">
                <canvas id="robotCanvas" style="width: 100%; height: auto;"></canvas>
                <div class="w-full flex justify-between items-center gap-4">
                    <button id="startSimulationBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-md shadow-lg transition duration-300 transform hover:scale-105 w-[20%]">
                        Start Simulation
                    </button>
                     <button id="stopSimulationBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-md shadow-lg transition duration-300 transform hover:scale-105 w-[20%]">
                        Stop
                    </button>
                    <div id="toolbar" class="w-[60%] flex justify-start items-center gap-4 p-4 rounded-lg bg-gray-800 shadow-sm">
                        <button id="measureBtn" class="bg-yellow-500 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-300">
                            Measure
                        </button>
                         <button id="createPathBtn" class="bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-300">
                            Create Path
                        </button>
                        <button id="saveBtn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-300">
                            Save
                        </button>
                        <button id="loadBtn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-300">
                            Load
                        </button>
                        <!-- New Opacity Slider for Second Map -->
                        <div class="flex flex-col items-center">
                            <label for="map2Opacity" class="text-sm font-medium text-gray-200">Map Opacity</label>
                            <input type="range" id="map2Opacity" min="0" max="1" value="0.5" step="0.1" class="mt-1 w-24">
                        </div>
                    </div>
                </div>
                <!-- Time Scrub Controls -->
                <div class="w-full p-6 bg-gray-800 rounded-lg shadow-sm">
                    <h2 class="text-xl font-semibold mb-4 text-gray-200">Time Scrub</h2>
                    <div class="flex items-center gap-4">
                        <span id="currentTimeDisplay" class="text-gray-200 font-bold w-12 text-right">0.0s</span>
                        <div class="flex items-center flex-grow">
                            <button id="rewindBtn" class="text-gray-200 font-bold text-2xl px-2">«</button>
                            <input type="range" id="timeSlider" min="0" max="1" step="0.001" value="0" class="w-full">
                            <button id="forwardBtn" class="text-gray-200 font-bold text-2xl px-2">»</button>
                        </div>
                        <span id="totalTimeDisplay" class="text-gray-200 font-bold w-12">0.0s</span>
                    </div>
                    <div class="flex items-center mt-4 gap-4">
                        <label for="playbackSpeed" class="text-sm font-medium text-gray-200 whitespace-nowrap">Playback Speed</label>
                        <input type="number" id="playbackSpeed" value="1.0" step="0.1" class="mt-1 w-[20%] text-right px-1 rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-700 text-gray-200">
                    </div>
                </div>
                
                <!-- Python Function Name Input Fields -->
                <div class="w-full p-6 bg-gray-800 rounded-lg shadow-sm">
                    <h2 class="text-xl font-semibold mb-4 text-gray-200">Python Function Names</h2>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="moveFunctionName" class="block text-sm font-medium text-gray-200">Move Function Name</label>
                            <input type="text" id="moveFunctionName" value="drive" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-700 text-gray-200">
                        </div>
                        <div>
                            <label for="rotateFunctionName" class="block text-sm font-medium text-gray-200">Rotate Function Name</label>
                            <input type="text" id="rotateFunctionName" value="rotateDegrees" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-700 text-gray-200">
                        </div>
                         <div>
                            <label for="motor1FunctionName" class="block text-sm font-medium text-gray-200">Motor 1 Function Name</label>
                            <input type="text" id="motor1FunctionName" value="rotateLeftArm" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-700 text-gray-200">
                        </div>
                        <div>
                            <label for="motor2FunctionName" class="block text-sm font-medium text-gray-200">Motor 2 Function Name</label>
                            <input type="text" id="motor2FunctionName" value="rotateRightArm" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 bg-gray-700 text-gray-200">
                        </div>
                    </div>
                </div>
                <div class="w-full p-6 bg-gray-800 rounded-lg shadow-sm">
                    <h2 class="text-xl font-semibold mb-4 text-gray-200">Generated Python Code</h2>
                    <div id="codeOutput" class="code-output p-4">
                        Your generated code will appear here.
                    </div>
                    <div class="flex flex-col md:flex-row gap-4 mt-4">
                      <button id="copyCodeBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-300">
                          Copy Code
                      </button>
                      <button id="downloadCodeBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-md shadow-md transition duration-300">
                          Download Python File
                      </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <input type="file" id="fileInput" accept=".json" class="hidden">

    <script>
        // DOM element references
        const canvas = document.getElementById('robotCanvas');
        const ctx = canvas.getContext('2d');
        const missionNameInput = document.getElementById('missionName');
        const startXInput = document.getElementById('startX');
        const startYInput = document.getElementById('startY');
        const startAngleInput = document.getElementById('startAngle');
        const robotWidthInput = document.getElementById('robotWidth');
        const robotHeightInput = document.getElementById('robotHeight');
        const pivotYInput = document.getElementById('pivotY');
        const moveDistanceInput = document.getElementById('moveDistance');
        const rotateAngleInput = document.getElementById('rotateAngle');
        const moveSpeedInput = document.getElementById('moveSpeed');
        const rotateSpeedInput = document.getElementById('rotateSpeed');
        const addMoveBtn = document.getElementById('addMoveBtn');
        const addRotateBtn = document.getElementById('addRotateBtn');
        const addMotor1Btn = document.getElementById('addMotor1Btn');
        const addMotor2Btn = document.getElementById('addMotor2Btn');
        const startSimulationBtn = document.getElementById('startSimulationBtn');
        const stopSimulationBtn = document.getElementById('stopSimulationBtn');
        const resetBtn = document.getElementById('resetBtn');
        const instructionList = document.getElementById('instructionList');
        const codeOutput = document.getElementById('codeOutput');
        const copyCodeBtn = document.getElementById('copyCodeBtn');
        const downloadCodeBtn = document.getElementById('downloadCodeBtn');
        const pathColorInput = document.getElementById('pathColor');
        const robotColorInput = document.getElementById('robotColor');
        const moveFunctionNameInput = document.getElementById('moveFunctionName');
        const rotateFunctionNameInput = document.getElementById('rotateFunctionName');
        const motor1FunctionNameInput = document.getElementById('motor1FunctionName');
        const motor2FunctionNameInput = document.getElementById('motor2FunctionName');
        const measureBtn = document.getElementById('measureBtn');
        const createPathBtn = document.getElementById('createPathBtn');
        const saveBtn = document.getElementById('saveBtn');
        const loadBtn = document.getElementById('loadBtn');
        const fileInput = document.getElementById('fileInput');
        const map2OpacityInput = document.getElementById('map2Opacity');
        const timeSlider = document.getElementById('timeSlider');
        const rewindBtn = document.getElementById('rewindBtn');
        const forwardBtn = document.getElementById('forwardBtn');
        const currentTimeDisplay = document.getElementById('currentTimeDisplay');
        const totalTimeDisplay = document.getElementById('totalTimeDisplay');
        const playbackSpeedInput = document.getElementById('playbackSpeed');

        // Image for the background
        const backgroundImage = new Image();
        backgroundImage.crossOrigin = "anonymous";
        backgroundImage.src = "https://raw.githubusercontent.com/plasticarm/fllrobotsim/main/MapDiagram.png";
        let isImageLoaded = false;
        
        // Second image for the overlay
        const backgroundImage2 = new Image();
        backgroundImage2.crossOrigin = "anonymous";
        backgroundImage2.src = "https://raw.githubusercontent.com/plasticarm/fllrobotsim/main/MapImage.png";
        let isImage2Loaded = false;

        // Table and Canvas Dimensions
        const TABLE_WIDTH_MM = 2362;
        const TABLE_HEIGHT_MM = 1143;
        const TABLE_ASPECT_RATIO = TABLE_WIDTH_MM / TABLE_HEIGHT_MM;
        
        // Robot state
        let robot = {
            x: 0,
            y: 0,
            angle: 0, // In radians
            speed: 5 // Pixels per frame
        };
        let robotStateHistory = [];
        let totalMissionTime = 0;
        let playbackSpeed = 1.0;

        // Instructions
        let instructions = [];
        let dragSrcEl = null;

        // Drag and drop state for the robot
        let isDraggingRobot = false;

        // Measuring tool state
        let isMeasuring = false;
        let measurePoints = [];
        let isDraggingMeasurePoint = false;
        let draggedMeasurePointIndex = -1;
        
        // Path creation state
        let isCreatingPath = false;
        let pathPoints = [];
        let isDraggingPathPoint = false;
        let draggedPathPointIndex = -1;
        let hoveredPathPointIndex = -1;
        
        // Global helper functions
        const toRadians = (deg) => deg * Math.PI / 180;
        const toDegrees = (rad) => rad * 180 / Math.PI;

        /**
         * Calculates the correct canvas dimensions to maintain aspect ratio within its parent container.
         * @returns {{width: number, height: number}} The calculated dimensions.
         */
        function resizeCanvas() {
            const container = canvas.parentElement;
            let containerWidth = container.clientWidth;
            let containerHeight = container.clientHeight;
            let calculatedWidth, calculatedHeight;

            const containerAspectRatio = containerWidth / containerHeight;

            if (containerAspectRatio > TABLE_ASPECT_RATIO) {
                calculatedHeight = containerHeight;
                calculatedWidth = calculatedHeight * TABLE_ASPECT_RATIO;
            } else {
                calculatedWidth = containerWidth;
                calculatedHeight = calculatedWidth / TABLE_ASPECT_RATIO;
            }
            
            canvas.width = calculatedWidth;
            canvas.height = calculatedHeight;
        }

        /**
         * Converts cm coordinates to canvas pixels.
         * @param {number} cm - The value in centimeters.
         * @returns {number} The converted value in pixels.
         */
        function cmToPixels(cm) {
            const PIXELS_PER_CM = canvas.width / (TABLE_WIDTH_MM / 10);
            return cm * PIXELS_PER_CM;
        }

        /**
         * Converts canvas coordinates to table coordinates (centered).
         * @param {number} x - The canvas x coordinate.
         * @param {number} y - The canvas y coordinate.
         * @returns {{x: number, y: number}} The converted coordinates in cm.
         */
        function toTableCoords(x, y) {
            const PIXELS_PER_CM = canvas.width / (TABLE_WIDTH_MM / 10);
            return {
                x: (x - canvas.width / 2) / PIXELS_PER_CM,
                y: -(y - canvas.height / 2) / PIXELS_PER_CM
            };
        }

        /**
         * Converts table coordinates to canvas coordinates.
         * @param {number} x - The table x coordinate in cm.
         * @param {number} y - The table y coordinate in cm.
         * @returns {{x: number, y: number}} The converted coordinates in pixels.
         */
        function toCanvasCoords(x, y) {
            const PIXELS_PER_CM = canvas.width / (TABLE_WIDTH_MM / 10);
            return {
                x: x * PIXELS_PER_CM + canvas.width / 2,
                y: -y * PIXELS_PER_CM + canvas.height / 2
            };
        }

        /**
         * Draws a scaled grid and axes on the canvas.
         */
        function drawGrid() {
            ctx.fillStyle = '#f9fafb';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const gridSpacingCm = 10; // Draw a grid every 10cm
            const PIXELS_PER_CM = canvas.width / (TABLE_WIDTH_MM / 10);
            const gridSpacingPixels = gridSpacingCm * PIXELS_PER_CM;

            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 1;

            // Draw vertical grid lines
            for (let x = -Math.floor(TABLE_WIDTH_MM / 20) * gridSpacingCm; x <= Math.floor(TABLE_WIDTH_MM / 20) * gridSpacingCm; x += gridSpacingCm) {
                const canvasX = toCanvasCoords(x, 0).x;
                ctx.beginPath();
                ctx.moveTo(canvasX, 0);
                ctx.lineTo(canvasX, canvas.height);
                ctx.stroke();
            }

            // Draw horizontal grid lines
            for (let y = -Math.floor(TABLE_HEIGHT_MM / 20) * gridSpacingCm; y <= Math.floor(TABLE_HEIGHT_MM / 20) * gridSpacingCm; y += gridSpacingCm) {
                const canvasY = toCanvasCoords(0, y).y;
                ctx.beginPath();
                ctx.moveTo(0, canvasY);
                ctx.lineTo(canvas.width, canvasY);
                ctx.stroke();
            }

            // Draw axis lines
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 2;
            const origin = toCanvasCoords(0, 0);
            ctx.beginPath();
            ctx.moveTo(origin.x, 0);
            ctx.lineTo(origin.x, canvas.height);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, origin.y);
            ctx.lineTo(canvas.width, origin.y);
            ctx.stroke();
        }

        /**
         * Draws the background on the canvas, with a grid fallback.
         */
        function drawTable() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (isImageLoaded) {
                const imgWidth = backgroundImage.naturalWidth;
                const imgHeight = backgroundImage.naturalHeight;
                let drawWidth, drawHeight, drawX, drawY;

                // Scale to fit while maintaining aspect ratio
                let scaleFactor = Math.min(canvas.width / imgWidth, canvas.height / imgHeight);
                drawWidth = imgWidth * scaleFactor;
                drawHeight = imgHeight * scaleFactor;

                // Center the image
                drawX = (canvas.width - drawWidth) / 2;
                drawY = (canvas.height - drawHeight) / 2;
                
                ctx.drawImage(backgroundImage, drawX, drawY, drawWidth, drawHeight);

                // Draw second image with opacity
                if (isImage2Loaded) {
                    ctx.save();
                    ctx.globalAlpha = map2OpacityInput.value;
                    ctx.drawImage(backgroundImage2, drawX, drawY, drawWidth, drawHeight);
                    ctx.restore();
                }
            } else {
                drawGrid();
            }
        }

        /**
         * Draws the robot on the canvas.
         */
        function drawRobot() {
            const pos = toCanvasCoords(robot.x, robot.y);
            const w = cmToPixels(parseFloat(robotWidthInput.value));
            const h = cmToPixels(parseFloat(robotHeightInput.value));
            const pivotY = parseFloat(pivotYInput.value);
            const pivotY_px = cmToPixels(pivotY);

            ctx.save();
            ctx.translate(pos.x, pos.y);
            ctx.rotate(robot.angle);

            // Draw the robot body, visually offset by the pivotY
            ctx.fillStyle = robotColorInput.value;
            ctx.fillRect(-w/2, -h/2 + pivotY_px, w, h);
            
            // Draw the forward-facing line, also offset by pivotY
            ctx.strokeStyle = '#1e40af';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, pivotY_px);
            ctx.lineTo(0, -h/2 + pivotY_px);
            ctx.stroke();
            
            // Draw the grey pivot line (axle) on top
            ctx.strokeStyle = '#6b7280';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-w/2, 0);
            ctx.lineTo(w/2, 0);
            ctx.stroke();
            
            // Draw the wheels on top, at y=0
            const wheelWidth = cmToPixels(0.8);
            const wheelHeight = cmToPixels(5.5);
            const wheelOffset = w/2 + 2;
            ctx.fillStyle = '#60a5fa';
            ctx.fillRect(-wheelOffset, -wheelHeight/2, wheelWidth, wheelHeight);
            ctx.fillRect(wheelOffset - wheelWidth, -wheelHeight/2, wheelWidth, wheelHeight);

            ctx.restore();
        }

        /**
         * Draws the actual path the robot has taken.
         */
        function drawPathHistory() {
            if (robotStateHistory.length < 2) return;
            ctx.strokeStyle = pathColorInput.value;
            ctx.lineWidth = 3;
            ctx.beginPath();
            const startPos = toCanvasCoords(robotStateHistory[0].x, robotStateHistory[0].y);
            ctx.moveTo(startPos.x, startPos.y);
            
            for (let i = 1; i < robotStateHistory.length; i++) {
                const pos = toCanvasCoords(robotStateHistory[i].x, robotStateHistory[i].y);
                ctx.lineTo(pos.x, pos.y);
            }
            ctx.stroke();
        }

        /**
         * Draws the entire planned path as a dashed line.
         */
        function drawPlannedPath() {
            if (plannedPathPoints.length < 2) return;
            ctx.strokeStyle = '#6b7280'; // Grey color
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]); // Dashed line
            ctx.beginPath();
            const startPos = toCanvasCoords(plannedPathPoints[0].x, plannedPathPoints[0].y);
            ctx.moveTo(startPos.x, startPos.y);
            
            for (let i = 1; i < plannedPathPoints.length; i++) {
                const pos = toCanvasCoords(plannedPathPoints[i].x, plannedPathPoints[i].y);
                ctx.lineTo(pos.x, pos.y);
            }
            ctx.stroke();
            ctx.setLineDash([]); // Reset line dash to solid
        }

        /**
         * Draws lines, distances, and angles for a set of points.
         * @param {Array<Object>} points - The array of points to draw.
         * @param {string} color - The color for the lines and text.
         */
        function drawMeasurements(points, color) {
            if (points.length < 2) return;
        
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.font = '12px Inter';
            ctx.fillStyle = color;
            ctx.textAlign = 'center';
        
            // Draw lines and distances
            for (let i = 0; i < points.length - 1; i++) {
                const start = toCanvasCoords(points[i].x, points[i].y);
                const end = toCanvasCoords(points[i+1].x, points[i+1].y);
                
                // Draw line
                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.stroke();
        
                // Calculate and draw distance text
                const dx = points[i+1].x - points[i].x;
                const dy = points[i+1].y - points[i].y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                const midX = (start.x + end.x) / 2;
                const midY = (start.y + end.y) / 2;
                ctx.fillText(`${distance.toFixed(1)} cm`, midX, midY - 10);
            }
        
            // Draw angle arcs and text
            if (points.length >= 3) {
                for (let i = 0; i < points.length - 2; i++) {
                    const p1 = toCanvasCoords(points[i].x, points[i].y);
                    const p2 = toCanvasCoords(points[i+1].x, points[i+1].y);
                    const p3 = toCanvasCoords(points[i+2].x, points[i+2].y);
                    
                    const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
                    const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };
                    
                    const angle1 = Math.atan2(v1.y, v1.x);
                    const angle2 = Math.atan2(v2.y, v2.x);
                    
                    let angleDiff = angle2 - angle1;
                    
                    // Normalize to [-pi, pi]
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    // Draw the shorter arc
                    if (Math.abs(angleDiff) > Math.PI) {
                        ctx.arc(p2.x, p2.y, 20, angle1, angle1 + (2*Math.PI-Math.abs(angleDiff)) * Math.sign(angleDiff));
                    } else {
                        ctx.arc(p2.x, p2.y, 20, angle1, angle2);
                    }
                    ctx.stroke();
        
                    const angleDeg = Math.abs(angleDiff) * 180 / Math.PI;
                    const angleTextPos = {
                        x: p2.x + 20 * Math.cos((angle1 + angle2) / 2),
                        y: p2.y + 20 * Math.sin((angle1 + angle2) / 2)
                    };
                    ctx.fillText(`${angleDeg.toFixed(1)}°`, angleTextPos.x, angleTextPos.y);
                }
            }
        }

        /**
         * Draws the measuring points and the distance/angle between them.
         */
        function drawMeasurePoints() {
            measurePoints.forEach(point => {
                const pos = toCanvasCoords(point.x, point.y);
                ctx.fillStyle = '#facc15';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 5, 0, 2 * Math.PI);
                ctx.fill();
            });

            drawMeasurements(measurePoints, '#facc15');
        }

        /**
         * Draws the path points.
         */
        function drawPathPoints() {
            pathPoints.forEach((point, index) => {
                const pos = toCanvasCoords(point.x, point.y);
                // Highlight hovered point
                if (index === hoveredPathPointIndex) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 8, 0, 2 * Math.PI);
                    ctx.fill();
                }

                ctx.fillStyle = '#800080'; // Purple
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 5, 0, 2 * Math.PI);
                ctx.fill();
            });
            drawMeasurements(pathPoints, '#800080');
        }

        /**
         * Main drawing function.
         */
        function draw() {
            drawTable();
            drawPlannedPath();
            drawPathHistory();
            drawMeasurePoints();
            drawPathPoints();
            drawRobot();
        }

        /**
         * Calculates the total time for the mission.
         */
        function calculateTotalTime() {
            let totalTime = 0;
            let finalState = {
                x: parseFloat(startXInput.value),
                y: parseFloat(startYInput.value),
                angle: parseFloat(startAngleInput.value) * Math.PI / 180,
            };

            instructions.forEach(instruction => {
                const moveSpeed = instruction.speed || 1000;
                const rotateSpeed = instruction.speed || 500;
                
                if (instruction.type === 'move') {
                    totalTime += instruction.distance / (moveSpeed / 100);
                    finalState.x += instruction.distance * Math.sin(finalState.angle);
                    finalState.y += instruction.distance * Math.cos(finalState.angle);
                } else if (instruction.type === 'rotate') {
                    totalTime += Math.abs(instruction.angle) / (rotateSpeed / 10);
                    finalState.angle += toRadians(instruction.angle);
                } else if (instruction.type === 'followPath') {
                    let pathCurrentX = finalState.x;
                    let pathCurrentY = finalState.y;
                    let pathCurrentAngleRad = finalState.angle;
                    
                    instruction.points.forEach(point => {
                        const dx = point.x - pathCurrentX;
                        const dy = point.y - pathCurrentY;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        const targetAngleRad = Math.atan2(dx, dy);
                        let angleDiffRad = targetAngleRad - pathCurrentAngleRad;
                        
                        while(angleDiffRad > Math.PI) angleDiffRad -= 2 * Math.PI;
                        while(angleDiffRad < -Math.PI) angleDiffRad += 2 * Math.PI;
                        
                        const angleDiffDeg = toDegrees(angleDiffRad);
                        
                        totalTime += Math.abs(angleDiffDeg) / (1000 / 10);
                        totalTime += distance / (1000 / 100);

                        pathCurrentAngleRad += angleDiffRad;
                        pathCurrentX = point.x;
                        pathCurrentY = point.y;
                    });
                    finalState.x = pathCurrentX;
                    finalState.y = pathCurrentY;
                    finalState.angle = pathCurrentAngleRad;
                } else if (instruction.type === 'motor1' || instruction.type === 'motor2') {
                    totalTime += 1; // 1 second pause
                }
            });
            totalMissionTime = totalTime;
            totalTimeDisplay.textContent = `${totalMissionTime.toFixed(1)}s`;
        }
        
        /**
         * Calculates the planned path based on all instructions.
         */
        function calculatePlannedPath() {
            plannedPathPoints = [];
            let currentX = parseFloat(startXInput.value);
            let currentY = parseFloat(startYInput.value);
            let currentAngleRad = parseFloat(startAngleInput.value) * Math.PI / 180;
            const pivotY = parseFloat(pivotYInput.value);

            plannedPathPoints.push({ x: currentX, y: currentY });

            instructions.forEach(instruction => {
                if (instruction.type === 'move') {
                    const distance = instruction.distance;
                    currentX += distance * Math.sin(currentAngleRad);
                    currentY += distance * Math.cos(currentAngleRad);
                    plannedPathPoints.push({ x: currentX, y: currentY });
                } else if (instruction.type === 'rotate') {
                    const angle = instruction.angle;
                    const oldAngleRad = currentAngleRad;
                    currentAngleRad += toRadians(angle);
                } else if (instruction.type === 'followPath') {
                    instruction.points.forEach(point => {
                        const dx = point.x - currentX;
                        const dy = point.y - currentY;
                        const targetAngleRad = Math.atan2(dx, dy);
                        currentAngleRad = targetAngleRad;
                        currentX = point.x;
                        currentY = point.y;
                        plannedPathPoints.push({ x: currentX, y: currentY });
                    });
                } else if (instruction.type === 'motor1' || instruction.type === 'motor2') {
                    // Motor commands do not change position or angle in planned path
                }
            });
            draw();
        }

        /**
         * Generates the Python code for the robot's movements.
         */
        function generatePythonCode() {
            const missionName = missionNameInput.value || 'Robot Mission';
            const startX = parseFloat(startXInput.value).toFixed(2);
            const startY = parseFloat(startYInput.value).toFixed(2);
            const startAngle = parseFloat(startAngleInput.value).toFixed(2);
            const moveFunction = moveFunctionNameInput.value || 'drive';
            const rotateFunction = rotateFunctionNameInput.value || 'rotateDegrees';
            const motor1Function = motor1FunctionNameInput.value || 'rotateLeftArm';
            const motor2Function = motor2FunctionNameInput.value || 'rotateRightArm';

            let code = `
# This code was automatically generated for mission: ${missionName}
# It assumes a library named '*' with asynchronous commands for movement and rotation.
"""
Available functions in the common library:

setupMotors()
resetYaw()
degreesForDistance(distance_cm)
drive(distance, speed)
rotateRightArm(degrees, speed)
rotateLeftArm(degrees, speed)
rotateCenterArm(degrees, speed)
resetArmRotation()
turn_done()
rotateDegrees(degrees, speed)
spin_turn(robot_degrees, motor_speed)
pivot_turn(robot_degrees, motor_speed)
all_done()
beep(frequency, duration)
"""

from common import *
import runloop

async def main():
    # Starting mission: ${missionName}
    # Initial Position: ${startX}, ${startY} cm
    # Initial Angle: ${startAngle} degrees   
    # Initialize the motor pair for wheels and save motor positions. Do this every time.
    await init()

`;
            let current_x = parseFloat(startXInput.value);
            let current_y = parseFloat(startYInput.value);
            let current_angle_deg = parseFloat(startAngleInput.value);
            const toRadians = (deg) => deg * Math.PI / 180;
            const toDegrees = (rad) => rad * 180 / Math.PI;
            
            instructions.forEach((instruction, index) => {
                const moveSpeed = instruction.speed || 1000;
                const rotateSpeed = instruction.speed || 500;
                
                if (instruction.type === 'move') {
                    const distance = instruction.distance;
                    code += `    await ${moveFunction}(${distance.toFixed(2)}, ${moveSpeed.toFixed(0)})\n`;
                    const angleRad = toRadians(current_angle_deg);
                    current_x += distance * Math.sin(angleRad);
                    current_y += distance * Math.cos(angleRad);
                } else if (instruction.type === 'rotate') {
                    const angle = instruction.angle;
                    code += `    await ${rotateFunction}(${angle.toFixed(2)}, ${rotateSpeed.toFixed(0)})\n`;
                    current_angle_deg += angle;
                } else if (instruction.type === 'followPath') {
                    let pathCurrentX = current_x;
                    let pathCurrentY = current_y;
                    let pathCurrentAngleDeg = current_angle_deg;

                    instruction.points.forEach((point, pointIndex) => {
                        const dx = point.x - pathCurrentX;
                        const dy = point.y - pathCurrentY;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        const targetAngleRad = Math.atan2(dx, dy);
                        const oldAngleRad = toRadians(pathCurrentAngleDeg);

                        let angleDiffRad = targetAngleRad - oldAngleRad;
                        
                        while(angleDiffRad > Math.PI) angleDiffRad -= 2 * Math.PI;
                        while(angleDiffRad < -Math.PI) angleDiffRad += 2 * Math.PI;
                        
                        const angleDiffDeg = toDegrees(angleDiffRad);
                        
                        pathCurrentAngleDeg += angleDiffDeg;

                        code += `    await ${rotateFunction}(${angleDiffDeg.toFixed(2)}, ${1000})\n`;
                        code += `    await ${moveFunction}(${distance.toFixed(2)}, ${1000})\n`;

                        pathCurrentX = point.x;
                        pathCurrentY = point.y;
                    });
                    
                    current_x = pathCurrentX;
                    current_y = pathCurrentY;
                    current_angle_deg = pathCurrentAngleDeg;
                } else if (instruction.type === 'motor1') {
                    code += `    await ${motor1Function}(${instruction.angle.toFixed(0)}, ${instruction.speed.toFixed(0)})\n`;
                } else if (instruction.type === 'motor2') {
                    code += `    await ${motor2Function}(${instruction.angle.toFixed(0)}, ${instruction.speed.toFixed(0)})\n`;
                }
            });
            
            code += `
    # reset the arms before finishing so they are ready to go again.
    await resetArmRotation()

runloop.run(main())
`;
            codeOutput.textContent = code;
        }
        
        /**
         * Calculates the robot's state (position, angle) at a given time.
         */
        function getRobotStateAtTime(time) {
            let currentX = parseFloat(startXInput.value);
            let currentY = parseFloat(startYInput.value);
            let currentAngleRad = parseFloat(startAngleInput.value) * Math.PI / 180;
            const pivotY = parseFloat(pivotYInput.value);
            
            let elapsedTime = 0;
            let finalState = { x: currentX, y: currentY, angle: currentAngleRad, pathHistory: [{ x: currentX, y: currentY }] };

            if (time <= 0) {
                return finalState;
            }

            for (const instruction of instructions) {
                let duration = 0;
                let finalX = currentX;
                let finalY = currentY;
                let finalAngleRad = currentAngleRad;
                
                const moveSpeed = instruction.speed || 1000;
                const rotateSpeed = instruction.speed || 500;

                if (instruction.type === 'move') {
                    duration = instruction.distance / (moveSpeed / 100);
                    if (elapsedTime + duration >= time) {
                        const timeInInstruction = time - elapsedTime;
                        const distMoved = (moveSpeed / 100) * timeInInstruction;
                        finalX = currentX + distMoved * Math.sin(currentAngleRad);
                        finalY = currentY + distMoved * Math.cos(currentAngleRad);
                        finalState.pathHistory.push({x: finalX, y: finalY});
                        finalState.x = finalX;
                        finalState.y = finalY;
                        finalState.angle = finalAngleRad;
                        return finalState;
                    }
                    finalX = currentX + instruction.distance * Math.sin(currentAngleRad);
                    finalY = currentY + instruction.distance * Math.cos(currentAngleRad);
                    finalState.pathHistory.push({x: finalX, y: finalY});
                } else if (instruction.type === 'rotate') {
                    duration = Math.abs(instruction.angle) / (rotateSpeed / 10);
                    if (elapsedTime + duration >= time) {
                        const timeInInstruction = time - elapsedTime;
                        const angleRotated = (rotateSpeed / 10) * Math.sign(instruction.angle) * timeInInstruction;
                        finalAngleRad = currentAngleRad + toRadians(angleRotated);
                        
                        finalX = currentX;
                        finalY = currentY;
                        finalState.angle = finalAngleRad;
                        return finalState;
                    }
                    finalAngleRad = currentAngleRad + toRadians(instruction.angle);
                    
                    finalX = currentX;
                    finalY = currentY;
                } else if (instruction.type === 'followPath') {
                    let pathCurrentX = currentX;
                    let pathCurrentY = currentY;
                    let pathCurrentAngleRad = currentAngleRad;
                    const originalElapsedTime = elapsedTime;

                    for (const point of instruction.points) {
                        const dx = point.x - pathCurrentX;
                        const dy = point.y - pathCurrentY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const targetAngleRad = Math.atan2(dx, dy);
                        let angleDiffRad = targetAngleRad - pathCurrentAngleRad;

                        while(angleDiffRad > Math.PI) angleDiffRad -= 2 * Math.PI;
                        while(angleDiffRad < -Math.PI) angleDiffRad += 2 * Math.PI;
                        
                        const rotationDuration = Math.abs(toDegrees(angleDiffRad)) / (1000 / 10);
                        const moveDuration = distance / (1000 / 100);

                        if (elapsedTime + rotationDuration >= time) {
                            const timeInInstruction = time - elapsedTime;
                            const angleRotated = (1000 / 10) * Math.sign(angleDiffRad) * timeInInstruction;
                            finalAngleRad = pathCurrentAngleRad + toRadians(angleRotated);
                            
                            finalState.x = pathCurrentX; 
                            finalState.y = pathCurrentY;
                            finalState.angle = finalAngleRad;
                            return finalState;
                        }
                        
                        elapsedTime += rotationDuration;
                        pathCurrentAngleRad += angleDiffRad;
                        
                        if (elapsedTime + moveDuration >= time) {
                            const timeInInstruction = time - elapsedTime;
                            const distMoved = (1000 / 100) * timeInInstruction;
                            finalX = pathCurrentX + distMoved * Math.sin(pathCurrentAngleRad);
                            finalY = pathCurrentY + distMoved * Math.cos(pathCurrentAngleRad);
                            finalState.pathHistory.push({x: finalX, y: finalY});
                            finalState.x = finalX;
                            finalState.y = finalY;
                            finalState.angle = pathCurrentAngleRad;
                            return finalState;
                        }
                        
                        elapsedTime += moveDuration;
                        finalState.pathHistory.push({x: point.x, y: point.y});
                        pathCurrentX = point.x;
                        pathCurrentY = point.y;
                    }
                    finalX = pathCurrentX;
                    finalY = pathCurrentY;
                    finalAngleRad = pathCurrentAngleRad;
                } else if (instruction.type === 'motor1' || instruction.type === 'motor2') {
                    duration = 1;
                    if (elapsedTime + duration >= time) {
                        return finalState;
                    }
                }
                elapsedTime += duration;
                currentX = finalX;
                currentY = finalY;
                currentAngleRad = finalAngleRad;
            }

            finalState.x = currentX;
            finalState.y = currentY;
            finalState.angle = currentAngleRad;
            return finalState;
        }

        let animationFrameId = null;
        let lastTimestamp = 0;

        function animateSlider(timestamp) {
            if (!animationFrameId) return;

            const deltaTime = (timestamp - lastTimestamp) / 1000;
            const sliderValue = parseFloat(timeSlider.value);
            const newSliderValue = sliderValue + (deltaTime * playbackSpeed / totalMissionTime);
            
            timeSlider.value = newSliderValue;
            updateSimulationState(newSliderValue);

            if (newSliderValue >= 1) {
                handleStopSimulation();
                return;
            }

            lastTimestamp = timestamp;
            animationFrameId = requestAnimationFrame(animateSlider);
        }

        function updateSimulationState(normalizedTime) {
            const time = normalizedTime * totalMissionTime;
            const state = getRobotStateAtTime(time);
            robot.x = state.x;
            robot.y = state.y;
            robot.angle = state.angle;
            robotStateHistory = state.pathHistory;

            currentTimeDisplay.textContent = `${time.toFixed(1)}s`;
            draw();
        }

        /**
         * Renders the instruction list in the UI.
         */
        function renderInstructionList() {
            instructionList.innerHTML = '';
            instructions.forEach((instruction, index) => {
                const listItem = document.createElement('li');
                listItem.className = 'instruction-item';
                listItem.draggable = true;
                listItem.dataset.index = index;
                
                let text = `Instruction ${index + 1}: `;
                if (instruction.type === 'move') {
                    const speed = instruction.speed || 1000;
                    text += `Move ${instruction.distance.toFixed(2)} cm @ ${speed.toFixed(0)}`;
                } else if (instruction.type === 'rotate') {
                    const speed = instruction.speed || 500;
                    text += `Rotate ${instruction.angle.toFixed(2)} deg @ ${speed.toFixed(0)}`;
                } else if (instruction.type === 'followPath') {
                    text += `Follow Path (${instruction.points.length} points)`;
                } else if (instruction.type === 'motor1') {
                    const speed = instruction.speed || 500;
                    text += `Motor 1 Rot: 90 deg @ ${speed.toFixed(0)}`;
                } else if (instruction.type === 'motor2') {
                    const speed = instruction.speed || 500;
                    text += `Motor 2 Rot: 90 deg @ ${speed.toFixed(0)}`;
                }
                
                listItem.innerHTML = `
                    <span>${text}</span>
                    <div class="instruction-controls">
                        <button class="edit-btn" data-index="${index}">Edit</button>
                        <button class="delete-btn" data-index="${index}">Delete</button>
                    </div>
                `;
                
                instructionList.appendChild(listItem);
            });
            addDragListeners();
            generatePythonCode();
            calculateTotalTime();
            calculatePlannedPath();
        }

        function addDragListeners() {
            const items = instructionList.querySelectorAll('.instruction-item');
            items.forEach(item => {
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('dragleave', handleDragLeave);
                item.addEventListener('drop', handleDrop);
                item.addEventListener('dragend', handleDragEnd);
                
                const editBtn = item.querySelector('.edit-btn');
                editBtn.addEventListener('click', handleEditInstruction);

                const deleteBtn = item.querySelector('.delete-btn');
                deleteBtn.addEventListener('click', handleDeleteInstruction);
            });
        }

        function handleDragStart(e) {
            this.style.opacity = '0.4';
            dragSrcEl = this;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', this.innerHTML);
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            if (e.target.classList.contains('instruction-item')) {
                e.target.style.borderTop = '2px solid #22c55e';
            }
        }

        function handleDragLeave(e) {
            e.target.style.borderTop = '';
        }

        function handleDrop(e) {
            e.preventDefault();
            e.target.style.borderTop = '';
            if (dragSrcEl !== this) {
                const dragIndex = parseInt(dragSrcEl.dataset.index);
                const dropIndex = parseInt(this.dataset.index);
                
                const [removed] = instructions.splice(dragIndex, 1);
                instructions.splice(dropIndex, 0, removed);
                
                renderInstructionList();
                draw();
            }
        }

        function handleDragEnd(e) {
            this.style.opacity = '1';
            dragSrcEl = null;
            calculatePlannedPath();
        }

        function handleEditInstruction(e) {
            const index = e.target.dataset.index;
            const instruction = instructions[index];
            const listItem = e.target.closest('li');
            
            let formHtml = '';
            if (instruction.type === 'move') {
                const speed = instruction.speed || 1000;
                formHtml = `
                    <form class="edit-form flex items-center gap-2" data-index="${index}">
                        <input type="number" name="distance" value="${instruction.distance.toFixed(2)}" step="0.01">
                        <input type="number" name="speed" value="${speed.toFixed(0)}" step="10">
                        <button type="submit">Save</button>
                    </form>
                `;
            } else if (instruction.type === 'rotate') {
                const speed = instruction.speed || 500;
                formHtml = `
                    <form class="edit-form flex items-center gap-2" data-index="${index}">
                        <input type="number" name="angle" value="${instruction.angle.toFixed(2)}" step="0.01">
                        <input type="number" name="speed" value="${speed.toFixed(0)}" step="10">
                        <button type="submit">Save</button>
                    </form>
                `;
            } else if (instruction.type === 'followPath') {
                 // Re-enable the path creation tool for editing
                isCreatingPath = true;
                pathPoints = instruction.points;
                createPathBtn.textContent = 'Finish Path';
                createPathBtn.classList.remove('bg-purple-500');
                createPathBtn.classList.add('bg-purple-700');
                instructions.splice(index, 1); // Temporarily remove the instruction from the list
                renderInstructionList();
                draw();
                return;
            } else if (instruction.type === 'motor1' || instruction.type === 'motor2') {
                 // Do not allow editing these commands for now
                alert('Motor rotation commands are not editable in the simulator. You can delete and re-add them.');
                return;
            }
            
            listItem.innerHTML = formHtml;
            listItem.querySelector('form').addEventListener('submit', handleSaveEdit);
        }

        function handleSaveEdit(e) {
            e.preventDefault();
            const index = e.target.dataset.index;
            const instruction = instructions[index];

            if (instruction.type === 'move') {
                instruction.distance = parseFloat(e.target.elements.distance.value);
                instruction.speed = parseInt(e.target.elements.speed.value);
            } else if (instruction.type === 'rotate') {
                instruction.angle = parseFloat(e.target.elements.angle.value);
                instruction.speed = parseInt(e.target.elements.speed.value);
            }
            
            renderInstructionList();
            draw();
        }

        function handleDeleteInstruction(e) {
            const index = e.target.dataset.index;
            instructions.splice(index, 1);
            renderInstructionList();
            draw();
        }


        /**
         * Adds a move command from user input.
         */
        function handleAddMove() {
            const distance = parseFloat(moveDistanceInput.value);
            const speed = parseInt(moveSpeedInput.value);
            if (isNaN(distance) || isNaN(speed)) return;
            instructions.push({ type: 'move', distance, speed });
            renderInstructionList();
        }
        
        /**
         * Adds a rotate command from user input.
         */
        function handleAddRotate() {
            const angle = parseFloat(rotateAngleInput.value);
            const speed = parseInt(rotateSpeedInput.value);
            if (isNaN(angle) || isNaN(speed)) return;
            instructions.push({ type: 'rotate', angle, speed });
            renderInstructionList();
        }

        /**
         * Adds a motor 1 rotation command.
         */
        function handleAddMotor1() {
            instructions.push({ type: 'motor1', angle: 90, speed: 500 });
            renderInstructionList();
        }

        /**
         * Adds a motor 2 rotation command.
         */
        function handleAddMotor2() {
            instructions.push({ type: 'motor2', angle: 90, speed: 500 });
            renderInstructionList();
        }

        /**
         * Resets the simulation state.
         */
        function handleReset() {
            instructions = [];
            pathHistory = [];
            robot = { 
                x: parseFloat(startXInput.value), 
                y: parseFloat(startYInput.value), 
                angle: parseFloat(startAngleInput.value) * Math.PI / 180, 
                speed: 5
            };
            isSimulating = false;
            currentInstructionIndex = 0;
            startSimulationBtn.textContent = 'Start Simulation';
            instructionList.innerHTML = '';
            codeOutput.textContent = 'Your generated code will appear here.';
            measurePoints = [];
            pathPoints = [];
            isCreatingPath = false;
            isMeasuring = false;
            motorPauseStartTime = null;
            hoveredPathPointIndex = -1;
            measureBtn.classList.remove('bg-yellow-700');
            measureBtn.classList.add('bg-yellow-500');
            createPathBtn.classList.remove('bg-purple-700');
            createPathBtn.classList.add('bg-purple-500');
            calculateTotalTime();
            calculatePlannedPath();
            updateSimulationState(0);
        }

        /**
         * Starts the simulation.
         */
        function handleStartSimulation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            timeSlider.value = 0;
            updateSimulationState(0);
            lastTimestamp = performance.now();
            animationFrameId = requestAnimationFrame(animateSlider);
            startSimulationBtn.textContent = 'Playing...';
        }

        function handleStopSimulation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            startSimulationBtn.textContent = 'Start Simulation';
        }

        /**
         * Copies the generated Python code to the clipboard.
         */
        function handleCopyCode() {
            try {
                const codeText = codeOutput.textContent;
                const textarea = document.createElement('textarea');
                textarea.value = codeText;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                copyCodeBtn.textContent = 'Copied!';
                setTimeout(() => {
                    copyCodeBtn.textContent = 'Copy Code';
                }, 2000);
            } catch (err) {
                console.error('Failed to copy text: ', err);
            }
        }
        
        /**
         * Downloads the generated Python code as a .py file.
         */
        function handleDownloadCode() {
            const codeText = codeOutput.textContent;
            const missionName = missionNameInput.value.replace(/[^a-zA-Z0-9]/g, '_') || 'robot_mission';
            const filename = `${missionName}.py`;
            const blob = new Blob([codeText], { type: 'text/x-python' });
            
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        }

        /**
         * Saves all relevant mission data as a JSON file.
         */
        function handleSave() {
            const missionData = {
                missionName: missionNameInput.value,
                startX: parseFloat(startXInput.value),
                startY: parseFloat(startYInput.value),
                startAngle: parseFloat(startAngleInput.value),
                robotWidth: parseFloat(robotWidthInput.value),
                robotHeight: parseFloat(robotHeightInput.value),
                pivotY: parseFloat(pivotYInput.value),
                pathColor: pathColorInput.value,
                robotColor: robotColorInput.value,
                map2Opacity: parseFloat(map2OpacityInput.value),
                playbackSpeed: parseFloat(playbackSpeedInput.value),
                moveFunctionName: moveFunctionNameInput.value,
                rotateFunctionName: rotateFunctionNameInput.value,
                motor1FunctionName: motor1FunctionNameInput.value,
                motor2FunctionName: motor2FunctionNameInput.value,
                instructions: instructions,
            };

            const jsonData = JSON.stringify(missionData, null, 2);
            const filename = `${missionNameInput.value.replace(/[^a-zA-Z0-9]/g, '_') || 'robot_mission'}.json`;
            const blob = new Blob([jsonData], { type: 'application/json' });

            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        }

        /**
         * Loads a mission from a selected JSON file.
         */
        function handleLoad() {
            fileInput.click();
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const loadedData = JSON.parse(e.target.result);
                    
                    missionNameInput.value = loadedData.missionName || 'Robot Mission';
                    startXInput.value = loadedData.startX || -93.0;
                    startYInput.value = loadedData.startY || -48.0;
                    startAngleInput.value = loadedData.startAngle || 0;
                    robotWidthInput.value = loadedData.robotWidth || 12.5;
                    robotHeightInput.value = loadedData.robotHeight || 18;
                    pivotYInput.value = loadedData.pivotY || 0;
                    pathColorInput.value = loadedData.pathColor || '#22c55e';
                    robotColorInput.value = loadedData.robotColor || '#3b82f6';
                    map2OpacityInput.value = loadedData.map2Opacity || 0.5;
                    playbackSpeedInput.value = loadedData.playbackSpeed || 1.0;
                    moveFunctionNameInput.value = loadedData.moveFunctionName || 'drive';
                    rotateFunctionNameInput.value = loadedData.rotateFunctionName || 'rotateDegrees';
                    motor1FunctionNameInput.value = loadedData.motor1FunctionName || 'rotateLeftArm';
                    motor2FunctionNameInput.value = loadedData.motor2FunctionName || 'rotateRightArm';
                    
                    instructions = loadedData.instructions || [];
                    
                    // Clear other tool points
                    measurePoints = [];
                    pathPoints = [];
                    isCreatingPath = false;
                    isMeasuring = false;
                    
                    renderInstructionList();
                    draw();
                } catch (err) {
                    console.error('Failed to parse JSON file:', err);
                    alert('Failed to load mission. The file may be corrupted or in an invalid format.');
                }
            };
            reader.readAsText(file);
        }

        /**
         * Checks if a point is within the robot's bounding box.
         * @param {number} x - The x coordinate of the point.
         * @param {number} y - The y coordinate of the point.
         * @returns {boolean} True if the point is inside the robot, false otherwise.
         */
        function isPointInRobot(x, y) {
            const robotCanvasPos = toCanvasCoords(robot.x, robot.y);
            const w = cmToPixels(parseFloat(robotWidthInput.value));
            const h = cmToPixels(parseFloat(robotHeightInput.value));
            const pivotY = cmToPixels(parseFloat(pivotYInput.value));

            const tempCtx = document.createElement('canvas').getContext('2d');
            tempCtx.save();
            tempCtx.translate(robotCanvasPos.x, robotCanvasPos.y);
            tempCtx.rotate(robot.angle);
            tempCtx.beginPath();
            // The bounding box is now offset
            tempCtx.rect(-w/2, -h/2 + pivotY, w, h);
            tempCtx.restore();
            return tempCtx.isPointInPath(x, y);
        }

        /**
         * Checks if a point is within a measuring point's bounding box.
         * @param {number} x - The x coordinate of the point.
         * @param {number} y - The y coordinate of the point.
         * @returns {number} The index of the measuring point, or -1 if no point is found.
         */
        function isPointInMeasurePoint(x, y) {
            for (let i = 0; i < measurePoints.length; i++) {
                const point = measurePoints[i];
                const pointPos = toCanvasCoords(point.x, point.y);
                const dx = x - pointPos.x;
                const dy = y - pointPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance <= 5) { // 5 pixel radius
                    return i;
                }
            }
            return -1;
        }

        /**
         * Checks if a point is within a path point's bounding box.
         * @param {number} x - The x coordinate of the point.
         * @param {number} y - The y coordinate of the point.
         * @returns {number} The index of the path point, or -1 if no point is found.
         */
        function isPointInPathPoint(x, y) {
            for (let i = 0; i < pathPoints.length; i++) {
                const point = pathPoints[i];
                const pointPos = toCanvasCoords(point.x, point.y);
                const dx = x - pointPos.x;
                const dy = y - pointPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance <= 5) { // 5 pixel radius
                    return i;
                }
            }
            return -1;
        }

        // Event listeners for dragging the robot and waypoints
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (isPointInRobot(mouseX, mouseY)) {
                isDraggingRobot = true;
                canvas.style.cursor = 'grabbing';
            } else if (isMeasuring) {
                const pointIndex = isPointInMeasurePoint(mouseX, mouseY);
                if (pointIndex !== -1) {
                    isDraggingMeasurePoint = true;
                    draggedMeasurePointIndex = pointIndex;
                } else {
                    const newPoint = toTableCoords(mouseX, mouseY);
                    measurePoints.push(newPoint);
                    draw();
                }
            } else if (isCreatingPath) {
                const pointIndex = isPointInPathPoint(mouseX, mouseY);
                if (pointIndex !== -1) {
                    isDraggingPathPoint = true;
                    draggedPathPointIndex = pointIndex;
                } else {
                    const newPoint = toTableCoords(mouseX, mouseY);
                    pathPoints.push(newPoint);
                    draw();
                }
            } else {
                const isHoveringRobot = isPointInRobot(mouseX, mouseY);
                const isHoveringMeasurePoint = isPointInMeasurePoint(mouseX, mouseY) !== -1;
                const isHoveringPathPoint = isPointInPathPoint(mouseX, mouseY) !== -1;
                if (isHoveringRobot || isHoveringMeasurePoint || isHoveringPathPoint) {
                    canvas.style.cursor = 'grab';
                } else {
                    canvas.style.cursor = 'pointer';
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const newTableCoords = toTableCoords(mouseX, mouseY);

            if (isDraggingRobot) {
                robot.x = newTableCoords.x;
                robot.y = newTableCoords.y;
                startXInput.value = robot.x.toFixed(2);
                startYInput.value = robot.y.toFixed(2);
                draw();
            } else if (isDraggingMeasurePoint) {
                measurePoints[draggedMeasurePointIndex].x = newTableCoords.x;
                measurePoints[draggedMeasurePointIndex].y = newTableCoords.y;
                draw();
            } else if (isDraggingPathPoint) {
                pathPoints[draggedPathPointIndex].x = newTableCoords.x;
                pathPoints[draggedPathPointIndex].y = newTableCoords.y;
                draw();
            } else {
                hoveredPathPointIndex = isPointInPathPoint(mouseX, mouseY);
                const isHoveringRobot = isPointInRobot(mouseX, mouseY);
                const isHoveringMeasurePoint = isPointInMeasurePoint(mouseX, mouseY) !== -1;
                if (isHoveringRobot || isHoveringMeasurePoint || hoveredPathPointIndex !== -1) {
                    canvas.style.cursor = 'grab';
                } else {
                    canvas.style.cursor = 'pointer';
                }
            }
            if (isCreatingPath) {
                draw();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDraggingRobot = false;
            isDraggingMeasurePoint = false;
            draggedMeasurePointIndex = -1;
            isDraggingPathPoint = false;
            draggedPathPointIndex = -1;
            canvas.style.cursor = 'grab';
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (isCreatingPath && hoveredPathPointIndex !== -1) {
                    pathPoints.splice(hoveredPathPointIndex, 1);
                    hoveredPathPointIndex = -1; // Reset hover
                    draw();
                }
            }
        });

        // Event listeners
        addMoveBtn.addEventListener('click', handleAddMove);
        addRotateBtn.addEventListener('click', handleAddRotate);
        addMotor1Btn.addEventListener('click', handleAddMotor1);
        addMotor2Btn.addEventListener('click', handleAddMotor2);
        startSimulationBtn.addEventListener('click', handleStartSimulation);
        stopSimulationBtn.addEventListener('click', handleStopSimulation);
        resetBtn.addEventListener('click', handleReset);
        copyCodeBtn.addEventListener('click', handleCopyCode);
        downloadCodeBtn.addEventListener('click', handleDownloadCode);
        saveBtn.addEventListener('click', handleSave);
        loadBtn.addEventListener('click', handleLoad);
        fileInput.addEventListener('change', handleFileSelect);
        
        measureBtn.addEventListener('click', () => {
            isMeasuring = !isMeasuring;
            if (isMeasuring) {
                isCreatingPath = false; // Disable path creation
                createPathBtn.classList.remove('bg-purple-700');
                createPathBtn.classList.add('bg-purple-500');
                measureBtn.classList.remove('bg-yellow-500');
                measureBtn.classList.add('bg-yellow-700');
                measurePoints = []; // Clear old points
            } else {
                measureBtn.classList.remove('bg-yellow-700');
                measureBtn.classList.add('bg-yellow-500');
            }
            draw();
        });

        createPathBtn.addEventListener('click', () => {
            if (isCreatingPath) {
                // Finalize path
                if (pathPoints.length > 0) {
                    instructions.push({ type: 'followPath', points: pathPoints });
                    renderInstructionList();
                }
                pathPoints = [];
                isCreatingPath = false;
                createPathBtn.classList.remove('bg-purple-700');
                createPathBtn.classList.add('bg-purple-500');
            } else {
                // Start a new path
                isCreatingPath = true;
                isMeasuring = false; // Disable measuring tool
                measureBtn.classList.remove('bg-yellow-700');
                measureBtn.classList.add('bg-yellow-500');
                createPathBtn.classList.remove('bg-purple-500');
                createPathBtn.classList.add('bg-purple-700');
                pathPoints = [];
            }
            draw();
        });

        timeSlider.addEventListener('input', (e) => {
            const normalizedTime = parseFloat(e.target.value);
            updateSimulationState(normalizedTime);
        });
        
        rewindBtn.addEventListener('click', () => {
            timeSlider.value = Math.max(0, parseFloat(timeSlider.value) - 0.01);
            updateSimulationState(parseFloat(timeSlider.value));
        });

        forwardBtn.addEventListener('click', () => {
            timeSlider.value = Math.min(1, parseFloat(timeSlider.value) + 0.01);
            updateSimulationState(parseFloat(timeSlider.value));
        });

        playbackSpeedInput.addEventListener('input', (e) => {
            playbackSpeed = parseFloat(e.target.value);
            if (isNaN(playbackSpeed) || playbackSpeed <= 0) {
                playbackSpeed = 1.0;
            }
        });


        // Update robot position when user changes the input fields
        startXInput.addEventListener('change', () => {
            robot.x = parseFloat(startXInput.value);
            draw();
            calculatePlannedPath();
            calculateTotalTime();
            updateSimulationState(parseFloat(timeSlider.value));
        });
        startYInput.addEventListener('change', () => {
            robot.y = parseFloat(startYInput.value);
            draw();
            calculatePlannedPath();
            calculateTotalTime();
            updateSimulationState(parseFloat(timeSlider.value));
        });
        startAngleInput.addEventListener('change', () => {
            robot.angle = parseFloat(startAngleInput.value) * Math.PI / 180;
            draw();
            calculatePlannedPath();
            calculateTotalTime();
            updateSimulationState(parseFloat(timeSlider.value));
        });
        robotWidthInput.addEventListener('change', () => {
            draw();
            calculatePlannedPath();
        });
        robotHeightInput.addEventListener('change', () => {
            draw();
            calculatePlannedPath();
        });
        pivotYInput.addEventListener('change', () => {
            const h = parseFloat(robotHeightInput.value);
            const pivotY = parseFloat(pivotYInput.value);
            if (Math.abs(pivotY) > h/2) {
                pivotYInput.value = h/2 * Math.sign(pivotY);
            }
            draw();
            calculatePlannedPath();
        });
        
        // Initial draw and state setup
        handleReset();

        // Wait for the background image to load before initializing the canvas
        backgroundImage.onload = () => {
            isImageLoaded = true;
            resizeCanvas();
            draw();
        };

        backgroundImage.onerror = () => {
             console.error("Failed to load background image.");
             isImageLoaded = false;
             resizeCanvas();
             draw(); // Draw grid as fallback
        };
        
        backgroundImage2.onload = () => {
            isImage2Loaded = true;
            draw();
        };
        backgroundImage2.onerror = () => {
            console.error("Failed to load second background image.");
            isImage2Loaded = false;
            draw();
        };
        
        map2OpacityInput.addEventListener('input', () => {
            draw();
        });

        // Resize the canvas when the window size changes
        window.addEventListener('resize', () => {
            resizeCanvas();
            draw();
        });

        // Initial resize for the first load
        window.onload = () => {
            resizeCanvas();
            draw();
            calculatePlannedPath();
            calculateTotalTime();
            updateSimulationState(0);
        };
    </script>
</body>
</html>
